---
title: "Script 8 Core Microbiome Test"
author: "Laura Lardinois"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

--> Script N. 8 - Testing Core Microbiome Analyses

Most recent updates: 
- 2026-02-07 - LLL - add tax cleaning to script
- 2026-02-06 - LLL - create base script

In many host-associated microbiome studies, researchers try to determine a 'core' microbiome, which is meant to reflect truly 'host-associated' rather than transient (i.e., environmental microbes - or ones from the diet or other hosts that may have been in recent contact with the target host) microbial taxa. 

There are many different ways for doing this - for instance, in Clever et al. (2022) they use an Indicator Analysis using the `indval` function of the labdsv package (ordination & multivariate analysis for ecology), which "calculates the indicator value (fidelity and relative abundance) of species in clusters or types" (from the labdsv Rdocumentation page). To do this, they compare microbes in fish, the environment, and potential prey items and they obtain p-values using indicator analysis, correct for multiple tests (Bonferroni correction), then extract the significant (setting a threshold of p < 0.01) ASVs associated with fish. 

Clever et al. (2022) code tutorial: https://bocasbiome.github.io/wf1.html#run-indicator-analysis-to-identify-core-taxa

Another approach for this, as is offered by the microbiome package, would be to transform the data to composition (accounting for differences in sequencing depth), then calculate the 'core' as the taxa that exceed a given prevalence and detection threshold (e.g., relative abundance > 1% (detection), and found in >= 50% of samples). This has the advantage of not needing non-target microbiome samples (e.g. water vs. fish) to calculate a 'core' microbiome, but leaves the decision of what constitutes a reasonable threshold and prevalence up to the researcher (without really having an informative statistical decision-making framework behind this).

See microbiome package 'core' tutorial here: https://microbiome.github.io/tutorials/Core.html

```{r load required packages}
library(phyloseq) #microbiome data handling - phyloseq obj
library(microbiome) #multiple functions for analyzing and visualizing microbiome data
library(labdsv) #ordination & multivariate analysis for ecology, including indicator analysis
library(here) #simplify calls to read/write data to project folder with relative positioning
library(tidyverse) #data manipulation in tidy format
library(cowplot) #multi-panels!
```

We'll load our whole fish dataset to start, but it may make more sense to calculate a core microbiome per host species, given the differences between hosts, and/or merge the fish dataset with the water for these analyses to be able to run the indicator analysis (if I understand what it's doing correctly)

```{r read in fish microbiome data from script 3 b-div}
#I'm being lazy here and just copying intermediate phyloseq objects and other R files generated by these new analyses to the GitHub/git-tracked project

#fish skin dataset
ROHR_06_obj_phylo_root <- readRDS(here("Intermediate_R_objects/ROHR_06_obj_with_rooted_phylogenetic_tree_updated_names.rds"))
#water dataset
ROHR_08_obj_phylo_root <- readRDS(here("Intermediate_R_objects/ROHR_08_with_phylogenetic_tree_rooted.rds"))

#also read in updated water metadata to fix missing sites
ROHR_08_metadata <- read.csv(here("Intermediate_R_objects/ROHR_8_Water_Metadata_2025-11-27.csv"))
```

```{r rename phyloseq obj to play with}
ROHR_06 <- ROHR_06_obj_phylo_root
ROHR_08 <- ROHR_08_obj_phylo_root
```

```{r replace site metadata in water dataset}
#drop control samples
ROHR_08_metadata <- ROHR_08_metadata %>%
  filter(site != "Control")

unique(ROHR_08_metadata$site)
unique(sample_data(ROHR_06)$site)

ROHR_08_metadata <- ROHR_08_metadata %>%
  mutate(site = recode(site,
                       "Canales de Afuera" = "Afuera",
                       "Granito de Oro" = "Granito",
                       "Mogo Mogo" = "MogoMogo",
                       "Bahia Damas" = "Damas"))

#also fix "species" column for downstream comparisons
ROHR_08_metadata <- ROHR_08_metadata %>%
  mutate(species = if_else(is.na(species), "Water", species))

# Set rownames to RRR numbers to match phyloseq metadata
rownames(ROHR_08_metadata) <- ROHR_08_metadata$RRR

#check sample names match
sample_names(sample_data(ROHR_08_metadata))
sample_names(sample_data(ROHR_08))

ROHR_08_NEW <- phyloseq(
    otu_table(ROHR_08),
    tax_table(ROHR_08),
    sample_data(ROHR_08_metadata)
  )

sample_data(ROHR_08_NEW) #yay! sample data is complete!
```

```{r save water phyloseq w/ update site info}
saveRDS(ROHR_08_NEW, here("Intermediate_R_objects/ROHR_08_with_phylogenetic_tree_rooted_UPDATEDsites.rds"))
```

#### Read fixed water dataset here!

```{r read in new water dataset}
#water dataset
ROHR_08_NEW <- readRDS(here("Intermediate_R_objects/ROHR_08_with_phylogenetic_tree_rooted_UPDATEDsites.rds"))
```

#### Merge Fish & Water datasets

To run the indicator analysis, we'll need to merge the water and fish datasets

```{r merge phyloseq objs of fish and water}
#drop phylogenetic trees first to avoid merge issues
drop_tree <- function(ps) {
  phyloseq(
    otu_table(ps),
    tax_table(ps),
    sample_data(ps)
  )
}

ROHR_06_noTree <- drop_tree(ROHR_06)
ROHR_08_noTree <- drop_tree(ROHR_08_NEW)

ROHR_merged <- merge_phyloseq(
  ROHR_06_noTree,
  ROHR_08_noTree
)
```

Check sample metadata to be able to use it downstream

```{r extract metadata}
metadata <- as.data.frame(sample_data(ROHR_merged))
metadata #sample = "Swab" or "Water"

unique(metadata$site)
```



### CORE MICROBIOME TEST #1 - Indicator Analysis from JS workflow (in Clever et al. (2022))

```{r bind ASVs and convert tips from sequence to ASV IDs}
#bind ASVs to tax table
tax_table(ROHR_merged) <- cbind(tax_table(ROHR_merged),
                                           rownames(tax_table(ROHR_merged)))

colnames(tax_table(ROHR_merged)) <-
        c("Kingdom", "Phylum", "Class",
          "Order", "Family", "Genus", "ASV")

# replace ASV sequences with ASV IDs
taxa_names(ROHR_merged) <- 1:ntaxa(ROHR_merged)
taxa_names(ROHR_merged) <- paste("ASV_",
                                 taxa_names(ROHR_merged),
                                 sep = "") #this gives you "ASV_1", "ASV_2", assigned sequentially
```

```{r re-make phyloseq with updated structure}
ROHR_merged.all <- data.frame(tax_table(ROHR_merged))
ROHR_merged.new <- data.frame(ASV_ID = row.names(ROHR_merged.all),
                            ROHR_merged.all)
ROHR_merged.new <- ROHR_merged.new[, c(2,3,4,5,6,7,1,8)]
ROHR_merged.new2 <- as.matrix(ROHR_merged.new)
ROHR_merged <- merge_phyloseq(otu_table(ROHR_merged),
                                         tax_table(ROHR_merged.new2),
                                         sample_data(ROHR_merged)#,
                                         #phy_tree(ROHR_merged) #don't run this on the merged dataset, since we removed the phylogenetic tree to merge the two datasets
                                         )
saveRDS(ROHR_merged, "Intermediate_R_objects/ROHR_merged_with_ASV-ID.rds")
```

Not all taxa have assignments to genus level, so we'll want to round to most detailed taxonomic level that is not NA

```{r round to non-NA taxonomy}
#rename a copy to mess with taxononomic assignments
ROHR_merged_LCA <- ROHR_merged

# take highest assigned taxonomic resolution
tax.clean <- data.frame(tax_table(ROHR_merged_LCA))

# LLL edit: may want to clean up this taxonomy a bit beforehand, since you have "assignments" that are basically placeholders for when we don't know anything at that level
unique(tax.clean$Phylum) #to phylum-level, these are mostly clean, with just a few candidate phyla for which we don't know much (e.g. 'LCP-89', a candidate phylum of uncultivated anaerobic bacteria)
unique(tax.clean$Class) # at the class level it starts to get messy: you get 'subgroups' listed, that aren't really informative, plus some letter/number codes that also refer to uncertain taxonomy at lower levels

# list of questionably helpful class IDs: 
# Acidobacteriota: "Subgroup 22", "Subgroup 26"
# BD7-11, OM190, Pla3 lineage, Pla 4 lineage, 028H05-P-BN-P5... are all Planctomycetota 

for (i in 1:6){ tax.clean[,i] <- as.character(tax.clean[,i])}
tax.clean[is.na(tax.clean)] <- ""

for (i in 1:nrow(tax.clean)){
    if (tax.clean[i,2] == ""){
        Kingdom <- base::paste("k", tax.clean[i,1], sep = "_")
        tax.clean[i, 2:6] <- Kingdom
    } else if (tax.clean[i,3] == ""){
        Phylum <- base::paste("p", tax.clean[i,2], sep = "_")
        tax.clean[i, 3:6] <- Phylum
    } else if (tax.clean[i,4] == ""){
        Class <- base::paste("c", tax.clean[i,3], sep = "_")
        tax.clean[i, 4:6] <- Class
    } else if (tax.clean[i,5] == ""){
        Order <- base::paste("o", tax.clean[i,4], sep = "_")
        tax.clean[i, 5:6] <- Order
    } else if (tax.clean[i,6] == ""){
        tax.clean$Genus[i] <- base::paste("f",tax.clean$Family[i], sep = "_")
        }
}
rm(Class, Order, Phylum, Kingdom) #if you get an error "...'Kingdom' not found", this likely means all are assigned to kingdom level

#append to ASV names
tax.clean <- tax.clean %>% unite("ASV_IDa", Genus:ASV_ID,
                                 remove = FALSE, sep = "_")
tax.clean <- tax.clean %>% unite("ASV_IDb", ASV_ID:Genus,
                                 remove = FALSE, sep = "_")
tax.clean <- tax.clean[, c(1,2,3,4,5,8,9,6,7,10)]
```

```{r LLL additional cleaning steps}
#check assigned names
#unique(tax.clean$Genus)

#make list of unhelpful names to merge with the order above
query_ids <- c(
  "P3OB-42","BIrii41","Eel-36e1D6","C8S-102","Sva1033","OM27 clade","SEEP-SRB4","PB19",
  "053A03-B-DI-P58","Sva0485","NB1-j","Blfdi19","MidBa8","Subgroup 10","Subgroup 22",
  "Subgroup 23","P13-46","C1-B045","KI89A clade","Subgroup 26","EC94","OM43 clade",
  "GKS98 freshwater group","MWH-UniP1 aquatic group","mle1-7","IS-44","2013Ark19i",
  "OM60(NOR5) clade","BD2-7","BD1-7 clade","OM182 clade","MBAE14","Gven-F17",
  "UBA10353 marine group","SUP05 cluster","SS1-B-02-17","PRD18C08","P.palmC41",
  "vadinBE97","Verruc-01","A714019","BD7-11","WPS-2","PAUC34f","SCGC AAA164-E04",
  "DBS1","DEV007","01D2Z36","WCHB1-41","R76-B128","vadinHA49","OM190",
  "Pla3 lineage","Pla4 lineage","028H05-P-BN-P5","SM1A02","CL500-3",
  "Urania-1B-19 marine sediment group","FS140-16B-02 marine group","C86",
  "Pir4 lineage","SH-PL14","B2706-C7","37-13","NS7 marine group","NS9 marine group",
  "NS10 marine group","NS11-12 marine group","NS5 marine group","NS4 marine group",
  "NS2b marine group","LCP-89","JdFR-76","possible genus 03","JGI 0000069-P22",
  "SCGC AAA286-E23","Marine Group II","Marine Group III",
  "Marine Benthic Group D and DHVEG-1","MBIC10086","UCYN-C","RF39","Subgroup 9",
  "67-14","Sva0996 marine group","ML602J-51","PeM15","PAUC26f","A4b","SBR1031",
  "KD4-96","JG30-KF-CM45","UCG-004","DMI","NK4A214 group","UCG-005","UCG-008",
  "AEGEAN-169 marine group","MD3-55","Clade IV","Clade III","Clade II","Clade Ib",
  "Clade Ia","OM75 clade","HIMB11","PS1 clade","SM2D12","AT-s3-44","EF100-94H03",
  "OCS116 clade","S25-593","CH2b56","BD7-8","JTB23","MSB-1D1","Cm1-21",
  "FS142-36B-02","SS1-B-07-19","CI75cm.2.12","D90","pItb-vmat-80","SZB85",
  "B2M28","HTCC5015","ET-SHO"
)

# search for and append the next highest taxonomic info
append_parent_taxon <- function(tax.clean, query_ids) {

  tax_mat <- as.matrix(tax.clean)

  out <- lapply(query_ids, function(id) {

    pos <- which(tax_mat == id, arr.ind = TRUE)
    if (nrow(pos) == 0) return(NA_character_)

    # LEFTMOST column where the ID appears
    pos <- pos[which.min(pos[, "col"]), ]

    parent_col <- pos["col"] - 1
    if (parent_col < 1) return(NA_character_)

    paste(tax_mat[pos["row"], parent_col], id, sep = "_")
  })

  tibble(
    query_id = query_ids,
    appended_id = unlist(out)
  )
}

#append parent taxa to these listed taxa
appended_taxa <- append_parent_taxon(
  tax.clean = tax.clean,
  query_ids = query_ids
)

appended_taxa

#make lookup list with these
lookup <- appended_taxa$appended_id
names(lookup) <- appended_taxa$query_id

# drop failures (NA appended_id)
lookup <- lookup[!is.na(lookup)]

#replace matches in tax.clean df
tax.clean[] <- lapply(tax.clean, function(col) {
  ifelse(col %in% names(lookup), lookup[col], col)
})
```

```{r reformat taxa clean df}
# final reformatting steps from JS
tax.clean$ASV_IDa <-
  str_replace_all(tax.clean$ASV_IDa,
                  'Clostridium_sensu_stricto_[0-9]',
                  'Clostridium')
tax.clean$ASV_IDb <-
  str_replace_all(tax.clean$ASV_IDb,
                  'Clostridium_sensu_stricto_[0-9]',
                  'Clostridium')
tax.clean$ASV_IDc <- tax.clean$ASV_IDa
tax.clean$ASV_IDc <-
  str_replace_all(tax.clean$ASV_IDc,
                  '_ASV', '')
tax.clean <- tax.clean[, c(1,2,3,4,5,6,7,8,9,11,10)]
write.csv(tax.clean, "Intermediate_R_objects/ROHR_merged_tax_no_na.csv")
```

Now, we can add the taxonomy back to the phyloseq object with no NA gaps
```{r save updated phyloseq w ASV IDs and no NAs}
tax_table(ROHR_merged_LCA) <- as.matrix(tax.clean)
rank_names(ROHR_merged_LCA)
saveRDS(ROHR_merged_LCA, "Intermediate_R_objects/ROHR_merged_ASVID_no_NA.rds")
```

```{r remove rownames from ASV table}
data.IndVal.env.fish <- data.frame(otu_table(ROHR_merged_LCA))
data.IndVal.env.fish
data.IndVal.ASV <- tibble::remove_rownames(data.IndVal.env.fish)
data.IndVal.ASV
```


#### Make Indicator Value group files (fish vs. water) & (all different host species)

```{r generate an Ind value group file across ALL FISH}
data.IndVal.group <- data.frame(sample_data(ROHR_merged_LCA)) %>%
  select(sample) #adjust this to relevant column - in this case 'sample' is either "Water" or "Swab" (og example uses 'Fraction' for this)
data.IndVal.group$Status <- data.IndVal.group$sample
data.IndVal.group <- data.IndVal.group[, c(2,1)]
data.IndVal.group$Status <- str_replace(data.IndVal.group$Status, "Water", "1")
data.IndVal.group$Status <- str_replace(data.IndVal.group$Status, "Swab", "2")
data.IndVal.group$sample <- str_replace(data.IndVal.group$sample, "Swab", "Fish")
data.IndVal.group <- tibble::rownames_to_column(data.IndVal.group, "Label")
data.IndVal.group$Status <-  as.integer(data.IndVal.group$Status)
data.IndVal.group$sample <-  as.character(data.IndVal.group$sample)
```

```{r generate an Ind value group file BY FISH SPECIES}
# Extract sample metadata and select 'species' column
data.IndVal.group_sp <- data.frame(sample_data(ROHR_merged_LCA)) %>%
  select(species)  # species-level grouping

# Create Status column as integer group ID
data.IndVal.group_sp$Status_sp <- as.factor(data.IndVal.group_sp$species)
data.IndVal.group_sp$Status_sp <- as.integer(data.IndVal.group_sp$Status_sp)

# Keep species names in the sample column
data.IndVal.group_sp$sample_sp <- as.character(data.IndVal.group_sp$species)

# Add rownames as a "Label" column
data.IndVal.group_sp <- rownames_to_column(data.IndVal.group_sp, "Label_sp")

# Reorder columns: Status_sp first, sample_sp second, Label_sp third
data.IndVal.group_sp <- data.IndVal.group_sp[, c("Status_sp", "sample_sp", "Label_sp")]

# Optional: check number of groups
table(data.IndVal.group_sp$Status_sp) #looks about right: we have ~30-38 fish/species and 19 water samples
```

NOTE: we know that all of these encompass different seasons and different regions, which, especially for the water samples, really matter when it comes to structuring microbiome communities (see previous analyses!). However, at least in the context of the fish and establishing a 'core' microbiome, we want to find the taxa that are stably associated with the fish, and not fluctuating between seasons, so it makes sense to compare across all. We could, however, consider running an indicator analysis on the water alone, splitting the groups by season + region. 

#### Calculate Indicator Values

```{r calc ind vals fish (ALL) vs water}
set.seed(1280)
iva <- indval(data.IndVal.ASV, data.IndVal.group$Status, numitr=1000)
#Table of the significant indicator species at p= 0.05 (demo does p = 0.01, but this returns literally 5 fish and 1212 water taxa)
gr <- iva$maxcls[iva$pval <= 0.05]
iv <- iva$indcls[iva$pval <= 0.05]
pv <- iva$pval[iva$pval <= 0.05]
fr <- apply(data.IndVal.ASV > 0, 2, sum)[iva$pval <= 0.05]
indval.out <- data.frame(group = gr, indval = iv, pval = pv, freq = fr)
indval.out <- indval.out[order(indval.out$group, -indval.out$indval),]
indval.out
write.csv(indval.out,
          file = here("Intermediate_R_objects/IndVal_microbiome_water_fish_outputs_20260207_LLL.csv"))
```

```{r adjust for multiple testing}
## LL edits to include padj vals in df
indval.out <- indval.out %>%
  mutate(padj = p.adjust(pval, method = "bonferroni")) %>%
  relocate(padj, .after = pval)
#write csv
write.csv(indval.out,
          file = here("Intermediate_R_objects/IndVal_microbiome_water_fish_bonf_20260207_LLL.csv"))
```

NOTE: with our dataset, which has quite a bit more nuance than the demo dataset (i.e., many fish species, many fish samples, different regions & seasons + comparatively few water samples to match), we're getting p-adj values of 1 across the board, so this approach probably isn't the best. 

```{r calc ind vals across all species}
set.seed(1280)

# Run IndVal analysis using species-level grouping
iva_sp <- indval(data.IndVal.ASV, data.IndVal.group_sp$Status_sp, numitr=1000)

# Extract significant indicator taxa at p <= 0.05
gr_sp <- iva_sp$maxcls[iva_sp$pval <= 0.05]
iv_sp <- iva_sp$indcls[iva_sp$pval <= 0.05]
pv_sp <- iva_sp$pval[iva_sp$pval <= 0.05]
fr_sp <- apply(data.IndVal.ASV > 0, 2, sum)[iva_sp$pval <= 0.05]

# Combine into a results dataframe
indval.out_sp <- data.frame(
  group = gr_sp,
  indval = iv_sp,
  pval = pv_sp,
  freq = fr_sp
)

# Order by group and decreasing indval
indval.out_sp <- indval.out_sp[order(indval.out_sp$group, -indval.out_sp$indval), ]

# Inspect results
indval.out_sp

# Write CSV of raw IndVal results
write.csv(
  indval.out_sp,
  file = here("Intermediate_R_objects/IndVal_microbiome_species_outputs_raw_20260207_LLL.csv")
)
```

```{r  adjust for multiple testing species-level}
# Add Bonferroni-corrected padj column after pval
indval.out_sp <- indval.out_sp %>%
  mutate(padj = p.adjust(pval, method = "bonferroni")) %>%
  relocate(padj, .after = pval)

# Inspect results
indval.out_sp

# Write CSV of corrected IndVal results
write.csv(
  indval.out_sp,
  file = here("Intermediate_R_objects/IndVal_microbiome_species_outputs_bonf_20260207_LLL.csv")
)
```

```{r append species names to IndVal output}
# Create mapping from Status_sp -> species name
status_to_species <- data.IndVal.group_sp %>%
  select(Status_sp, sample_sp) %>%
  distinct()  # ensure one row per group

# Join species names into IndVal output
indval.out_sp <- indval.out_sp %>%
  left_join(status_to_species, by = c("group" = "Status_sp")) %>%
  rename(species_name = sample_sp)  # optional: explicit column name

# Reorder columns for readability
indval.out_sp <- indval.out_sp %>%
  select(group, species_name, indval, pval, padj, freq)

# Inspect
head(indval.out_sp)

# Write CSV with species names included
write.csv(
  indval.out_sp,
  file = here("Intermediate_R_objects/IndVal_microbiome_species_outputs_bonf_20260207_LLL.csv"),
  row.names = FALSE
)
```

LLL NOTE (2/7/26): in both test cases, the bonferroni correction returns p-adj values of 1 across the board - so none of these "indicator" taxa are technically significant by these metrics...

### FISH CORE MICROBIOME INDVAL SUMMARY - IN PROGRESS 2/7

```{r extract fish core ASVs}
fish_ind_asvs <- indval.out[indval.out$group == 2, ]
fish_ind_asvs_list <- row.names(fish_ind_asvs)
indv.core.ALL <- subset_taxa(ROHR_merged_LCA,
                               rownames(tax_table(ROHR_merged_LCA)) %in%
                                       fish_ind_asvs_list)
indv.core.ALL #12 taxa
```

```{r pull out only fish samples}
indv.core.ALL.fish <- subset_samples(indv.core.ALL, sample == "Swab")
sample_data(indv.core.ALL.fish)
tax.core <- tax_table(indv.core.ALL.fish)

write.csv(tax.core, file = "Intermediate_R_objects/tax_indVal_core.csv")
tax_core_mod <- read.csv("Intermediate_R_objects/tax_indVal_core.csv", header = TRUE, row.names = 1)
tax_core_mod2 <- as.matrix(tax_core_mod) 
```

```{r save ps object with core taxa}
indv.core.ALL.fish <- merge_phyloseq(otu_table(indv.core.ALL.fish),
                                    tax_table(tax_core_mod2),
                                    sample_data(indv.core.ALL.fish)#,
                                    #phy_tree(indv.core.ALL.fish)
                                    )
saveRDS(indv.core.ALL.fish, "Intermediate_R_objects/ps_indv01_core_fish.rds")
indv.core.ALL.fish <- readRDS("Intermediate_R_objects/ps_indv01_core_fish.rds")
indv.core.ALL.fish #12 taxa, 341 samples
```


### FISH CORE MICROBIOME INDVAL PLOTS - IN PROGRESS 2/7

# NEED TO TRANSFER COLOR CODES FROM MY FIGS

```{r set plot colors for ALL fish CORE plot}
#check ASVs returned
ASV_list <- indval.out %>% 
  filter(group == 2) %>% #pull just fish ones (group = 2)
  arrange(desc(freq)) %>% #sort by frequency of ocurrence, most common to least
 rownames(., )  #pull row names (ASV IDs)
ASV_list

#define ASV order in plot
asv_order <- rev(ASV_list)

ASV_colors <- c(
        "mediumaquamarine","darkcyan", 
        "darkseagreen2","turquoise",
        "dodgerblue1","dodgerblue3", 
        "lightsalmon3", "coral",
        "coral2","indianred2",
        "lavender","darkslategrey"
        ) #for current 12 'core' fish ASVs across the whole dataset (at p-val < 0.05)



level_order <- c('Coiba',
                 'Las Perlas')
level_order2 <- c('Cocos', 'Machete', 'Chapera', 'Pacheca',
                  'Afuera','Frijolito','Granito', 'Frijol', 
                  'Saboga', 'Uvas', 'Damas', 'Contadora', 'MogoMogo')
```


ASV_colors <- c(
        "mediumaquamarine","darkcyan", "darkseagreen2",
        "springgreen4", "lightseagreen","aquamarine2",
        "turquoise", "aquamarine","aquamarine4", "darkseagreen4",
        "dodgerblue1","dodgerblue3", "lightsalmon3", "coral",
        "coral2","darksalmon","lightsalmon","coral3", "salmon3" ,
        "indianred", "indianred2","salmon2", "salmon","lightsalmon4",
        "lavender","darkslategrey","plum3")


```{r tax glom to phylum and convert to rel abund}
ALL.fish.core <- indv.core.ALL.fish %>%
        tax_glom(taxrank = "ASV_IDa") %>%
        transform_sample_counts(function(x) {x/sum(x)} ) %>%
        psmelt() %>%
        filter(Abundance > 0.00) %>%
        arrange(ASV_IDa)
ALL.fish.core$ASV_ID <- gdata::reorder.factor(ALL.fish.core$ASV_ID, new.order = asv_order)
ALL.fish.core <- ALL.fish.core %>% dplyr::arrange(ASV_ID)
ALL.fish.core$ASV_IDa <- factor(ALL.fish.core$ASV_IDa, levels = unique(ALL.fish.core$ASV_IDa))
levels(ALL.fish.core$ASV_IDa)
attributes(ALL.fish.core$ASV_IDa)
```

```{r test plot all fish inval by REGION}
fig01 <- ggplot(ALL.fish.core, aes(x = factor(region, level = level_order),
                                y = Abundance, fill = ASV_IDa)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_manual(values = ASV_colors) +
        scale_x_discrete("Region", expand = waiver(),
                         position = "bottom", drop = FALSE) +
        guides(fill = guide_legend(reverse = TRUE,
                                   keywidth = 1,
                                   keyheight = 1,
                                   title="ASV ID")) + 
        ylab("") +
        ggtitle("", subtitle = "Core fish microbiome across all species") +
        theme(plot.title = element_text(size = 18)) +
        theme(plot.subtitle = element_text(size = 16)) +
        theme_cowplot()

fig01
```

```{r save prelim plot all fish Inval taxa}
ggsave(filename = "Test Core plot Indval 1 - all species together plotted by region.pdf", plot = fig01, path = here('Intermediate_R_objects/Figs'), width = 14, height = 10, device='pdf', dpi=300)
```


```{r test plot all fish inval by HOST SPECIES}
fig02 <-
        ggplot(ALL.fish.core, aes(x = species, y = Abundance, fill = ASV_IDa)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_manual(values = ASV_colors) +
        scale_x_discrete("", expand = waiver(),
                         position = "bottom", drop = FALSE) +
        guides(fill = guide_legend(reverse = TRUE,
                                   keywidth = 1,
                                   keyheight = 1,
                                   title = "ASV ID")) + 
        ylab("Relative Abundance (ASV)") +
        ggtitle("Fish skin core microbiome", subtitle = "") +
        theme_cowplot() +
  theme(plot.title = element_text(size = 18),
              axis.text.x = element_text(angle = 30, hjust = 1))

fig02
```

```{r save prelim plot all fish Inval taxa by SPECIES}
ggsave(filename = "Test Core plot Indval 1 - all species together plotted by species.pdf", plot = fig02, path = here('Intermediate_R_objects/Figs'), width = 14, height = 10, device='pdf', dpi=300)
```

## IN PROGRESS 2-7-26 - LLL - RUN GRAPHS WITH SPECIES-BY-SPECIES INDICATOR ANALYSIS






#### Test Invals in pairs: species 1 vs. water, species 2 vs. water, etc. to return 'core' by species, compared not to all other fish, but rather comparing each fish vs. water

# IN PROGRESS 2-8-26 LLL

```{r define fish groups}
#assuming water is always the last group appended (here we know water is group 11, since we merged it in last above)
fish_groups  <- sort(unique(data.IndVal.group_sp$Status_sp))
water_group  <- max(fish_groups)          # assumes Water = group 11
fish_groups  <- fish_groups[fish_groups != water_group]
```

```{r create lookup to link species names to group names}
status_to_species <- data.IndVal.group_sp %>%
  select(Status_sp, sample_sp) %>%
  distinct()
```

```{r}
#save copy of ASV table to mod
data.IndVal.ASV_sp <- data.IndVal.ASV
```


```{r run pairwise fish-water indval analyses}
set.seed(1280)

fish_groups  <- 1:10
water_group  <- 11

indval_list_sp <- lapply(fish_groups, function(g) {

  ## subset to fish g + water
  keep <- data.IndVal.group_sp$Status_sp %in% c(g, water_group)

  ASV_sub <- data.IndVal.ASV_sp[keep, , drop = FALSE]

  ## drop ASVs absent in both groups (CRITICAL)
  ASV_sub <- ASV_sub[, colSums(ASV_sub) > 0, drop = FALSE]

  grp_sub <- data.IndVal.group_sp$Status_sp[keep]
  grp_bin <- ifelse(grp_sub == g, 1, 2)

  iva <- indval(ASV_sub, grp_bin, numitr = 1000) 

  ## APPLY CUTOFF (exactly as in your example)
  sig <- iva$pval <= 0.05

  if (!any(sig)) return(NULL)

  data.frame(
    fish_group   = g,
    fish_species = status_to_species$sample_sp[
      match(g, status_to_species$Status_sp)
    ],
    ASV     = colnames(ASV_sub)[sig],
    group   = iva$maxcls[sig],
    indval  = iva$indcls[sig],
    pval    = iva$pval[sig],
    freq    = apply(ASV_sub > 0, 2, sum)[sig],
    stringsAsFactors = FALSE
  )
})

## bind all fish results
indval.out_sp_PAIRWISE <- bind_rows(indval_list_sp)
```

```{r}
indval.out_sp_PAIRWISE <- indval.out_sp_PAIRWISE %>%
  mutate(padj = p.adjust(pval, method = "bonferroni")) %>%
  relocate(padj, .after = pval) %>%
  arrange(fish_group, desc(indval)) #returns 11818 obs

#filter to keep only fish indicators (not water)
indval.out_sp_PAIRWISE <- indval.out_sp_PAIRWISE %>%
  filter(group == 1) %>%  #drops down to 354 obs
  arrange(fish_group, desc(indval))

#view table
indval.out_sp_PAIRWISE
```

### NEED TO DOUBLE-CHECK WHAT THIS IS PULLING - I think we're getting things from "group" = 2, which are indicator taxa for water (which isn't very helpful) - have now filtered these out to get 354 obs overall


```{r}
#pull ASV taxonomy
ASV_genus <- tax.clean %>%
  select(ASV_ID, Genus)

indval.out_sp_PAIRWISE <- indval.out_sp_PAIRWISE %>%
  left_join(ASV_genus, by = c("ASV" = "ASV_ID"))

indval.out_sp_PAIRWISE
```

```{r }
#write output
write.csv(
  indval.out_sp_PAIRWISE,
  here("Intermediate_R_objects/IndVal_species_vs_water_PAIRWISE_bonf_FISHONLY_20260208_LLL.csv"),
  row.names = FALSE
)
```

```{r}
#check overlaps in ASVs
ASV_overlap <- indval.out_sp_PAIRWISE %>%
  distinct(ASV, fish_group) %>%        # ensure 1 count per fish
  count(ASV, name = "n_fish") %>%       # number of fish each ASV is indicator for
  arrange(desc(n_fish))

ASV_overlap
```

```{r}
ASV_overlap_summary <- ASV_overlap %>%
  count(n_fish, name = "n_ASVs")

ASV_overlap_summary
```


```{r}
ggplot(ASV_overlap_summary, aes(x = n_fish, y = n_ASVs)) +
  geom_col() +
  labs(
    x = "Number of fish species an ASV is an indicator of",
    y = "Number of ASVs",
    title = "Overlap of Indicator ASVs Across Fish Species"
  ) +
  theme_bw()
```

```{r}
#check which fish share the most 'core' microbes

fish_ASV_mat <- indval.out_sp_PAIRWISE %>%
  distinct(fish_species, ASV) %>%   # one ASV per fish
  mutate(present = 1) %>%
  pivot_wider(
    names_from  = ASV,
    values_from = present,
    values_fill = 0
  )

# convert to matrix (rows = fish, cols = ASVs)
M <- as.matrix(fish_ASV_mat[, -1])
rownames(M) <- fish_ASV_mat$fish_species

# pairwise overlap = shared ASVs
overlap_mat <- M %*% t(M)

#count totals of ASVs by fish
fish_totals <- indval.out_sp_PAIRWISE %>%
  distinct(fish_species, ASV) %>%
  count(fish_species, name = "total_ASVs")

overlap_df <- overlap_df %>%
  left_join(
    fish_totals,
    by = c("fish_1" = "fish_species")
  ) %>%
  rename(total_ASVs_fish1 = total_ASVs) %>%
  left_join(
    fish_totals,
    by = c("fish_2" = "fish_species")
  ) %>%
  rename(total_ASVs_fish2 = total_ASVs) %>%
  mutate(
    pct_shared_fish1 = 100 * shared_ASVs / total_ASVs_fish1,
    pct_shared_fish2 = 100 * shared_ASVs / total_ASVs_fish2
  )

# Top overlapping pairs
overlap_df %>%
  arrange(desc(shared_ASVs)) %>%
  head(20)
```

```{r}
ASV_count_by_species <- indval.out_sp_PAIRWISE %>%
  distinct(fish_species, ASV) %>%   # ensure 1 ASV per species
  count(fish_species, name = "n_ASVs") %>%
  arrange(desc(n_ASVs))

ASV_count_by_species
```

```{r}
indval.out_sp_PAIRWISE %>%
  distinct(ASV) %>%
  nrow()
```


```{r}
ggplot(overlap_df, aes(fish_1, fish_2, fill = shared_ASVs)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  labs(
    x = "Fish species",
    y = "Fish species",
    fill = "Shared ASVs",
    title = "Pairwise Sharing of Indicator ASVs Between Fish Species"
  )
```









### CORE MICROBIOME TEST #2 - `microbiome` package: by detection & prevalence
## IN PROGRESS 2-6-26 - LLL

After these prep step, we can try out running the `core_members` function from the microbiome package!

#### RUN CORE MICROBIOME TEST - 'core_members'

```{r run core taxa function at 1% detection and 50% prevalence}
core.taxa.50 <- core_members(ROHR_06_LCA, detection = 0.0001, prevalence = 50/100)

core.taxa.50
```

We now have a list of 44 ASVs - however, these codes don't tell us much more than the sequences...

```{r }
# 
tax_table(ROHR_06.rel)[, colnames(tax_table(ROHR_06.rel))] <- gsub(tax_table(ROHR_06.rel)[, colnames(tax_table(ROHR_06.rel))],  pattern = "[a-z]__", replacement = "")

# Use the microbiome function add_besthit to get taxonomic identities of ASVs.
ROHR_06.rel.f <- microbiome::add_besthit(ROHR_06.rel, sep = " ")

# Check 
taxa_names(ROHR_06.rel.f)[1:10]
```
